// Code generated by protoc-gen-go. DO NOT EDIT.
// source: syncano/codebox/filerepo/v1/repo.proto

package filerepo

import (
	context "context"
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

type ExistsRequest struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExistsRequest) Reset()         { *m = ExistsRequest{} }
func (m *ExistsRequest) String() string { return proto.CompactTextString(m) }
func (*ExistsRequest) ProtoMessage()    {}
func (*ExistsRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d572c5447081dfe, []int{0}
}

func (m *ExistsRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExistsRequest.Unmarshal(m, b)
}
func (m *ExistsRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExistsRequest.Marshal(b, m, deterministic)
}
func (m *ExistsRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistsRequest.Merge(m, src)
}
func (m *ExistsRequest) XXX_Size() int {
	return xxx_messageInfo_ExistsRequest.Size(m)
}
func (m *ExistsRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistsRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ExistsRequest proto.InternalMessageInfo

func (m *ExistsRequest) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type ExistsResponse struct {
	Ok                   bool     `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ExistsResponse) Reset()         { *m = ExistsResponse{} }
func (m *ExistsResponse) String() string { return proto.CompactTextString(m) }
func (*ExistsResponse) ProtoMessage()    {}
func (*ExistsResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d572c5447081dfe, []int{1}
}

func (m *ExistsResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ExistsResponse.Unmarshal(m, b)
}
func (m *ExistsResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ExistsResponse.Marshal(b, m, deterministic)
}
func (m *ExistsResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ExistsResponse.Merge(m, src)
}
func (m *ExistsResponse) XXX_Size() int {
	return xxx_messageInfo_ExistsResponse.Size(m)
}
func (m *ExistsResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_ExistsResponse.DiscardUnknown(m)
}

var xxx_messageInfo_ExistsResponse proto.InternalMessageInfo

func (m *ExistsResponse) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

type UploadRequest struct {
	// Types that are valid to be assigned to Value:
	//	*UploadRequest_Meta
	//	*UploadRequest_Chunk
	//	*UploadRequest_Done
	Value                isUploadRequest_Value `protobuf_oneof:"value"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *UploadRequest) Reset()         { *m = UploadRequest{} }
func (m *UploadRequest) String() string { return proto.CompactTextString(m) }
func (*UploadRequest) ProtoMessage()    {}
func (*UploadRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d572c5447081dfe, []int{2}
}

func (m *UploadRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadRequest.Unmarshal(m, b)
}
func (m *UploadRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadRequest.Marshal(b, m, deterministic)
}
func (m *UploadRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest.Merge(m, src)
}
func (m *UploadRequest) XXX_Size() int {
	return xxx_messageInfo_UploadRequest.Size(m)
}
func (m *UploadRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest proto.InternalMessageInfo

type isUploadRequest_Value interface {
	isUploadRequest_Value()
}

type UploadRequest_Meta struct {
	Meta *UploadRequest_MetaMessage `protobuf:"bytes,1,opt,name=meta,proto3,oneof"`
}

type UploadRequest_Chunk struct {
	Chunk *UploadRequest_ChunkMessage `protobuf:"bytes,2,opt,name=chunk,proto3,oneof"`
}

type UploadRequest_Done struct {
	Done bool `protobuf:"varint,3,opt,name=done,proto3,oneof"`
}

func (*UploadRequest_Meta) isUploadRequest_Value() {}

func (*UploadRequest_Chunk) isUploadRequest_Value() {}

func (*UploadRequest_Done) isUploadRequest_Value() {}

func (m *UploadRequest) GetValue() isUploadRequest_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *UploadRequest) GetMeta() *UploadRequest_MetaMessage {
	if x, ok := m.GetValue().(*UploadRequest_Meta); ok {
		return x.Meta
	}
	return nil
}

func (m *UploadRequest) GetChunk() *UploadRequest_ChunkMessage {
	if x, ok := m.GetValue().(*UploadRequest_Chunk); ok {
		return x.Chunk
	}
	return nil
}

func (m *UploadRequest) GetDone() bool {
	if x, ok := m.GetValue().(*UploadRequest_Done); ok {
		return x.Done
	}
	return false
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*UploadRequest) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*UploadRequest_Meta)(nil),
		(*UploadRequest_Chunk)(nil),
		(*UploadRequest_Done)(nil),
	}
}

type UploadRequest_MetaMessage struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadRequest_MetaMessage) Reset()         { *m = UploadRequest_MetaMessage{} }
func (m *UploadRequest_MetaMessage) String() string { return proto.CompactTextString(m) }
func (*UploadRequest_MetaMessage) ProtoMessage()    {}
func (*UploadRequest_MetaMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d572c5447081dfe, []int{2, 0}
}

func (m *UploadRequest_MetaMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadRequest_MetaMessage.Unmarshal(m, b)
}
func (m *UploadRequest_MetaMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadRequest_MetaMessage.Marshal(b, m, deterministic)
}
func (m *UploadRequest_MetaMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest_MetaMessage.Merge(m, src)
}
func (m *UploadRequest_MetaMessage) XXX_Size() int {
	return xxx_messageInfo_UploadRequest_MetaMessage.Size(m)
}
func (m *UploadRequest_MetaMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest_MetaMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest_MetaMessage proto.InternalMessageInfo

func (m *UploadRequest_MetaMessage) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

type UploadRequest_ChunkMessage struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Data                 []byte   `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadRequest_ChunkMessage) Reset()         { *m = UploadRequest_ChunkMessage{} }
func (m *UploadRequest_ChunkMessage) String() string { return proto.CompactTextString(m) }
func (*UploadRequest_ChunkMessage) ProtoMessage()    {}
func (*UploadRequest_ChunkMessage) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d572c5447081dfe, []int{2, 1}
}

func (m *UploadRequest_ChunkMessage) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadRequest_ChunkMessage.Unmarshal(m, b)
}
func (m *UploadRequest_ChunkMessage) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadRequest_ChunkMessage.Marshal(b, m, deterministic)
}
func (m *UploadRequest_ChunkMessage) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadRequest_ChunkMessage.Merge(m, src)
}
func (m *UploadRequest_ChunkMessage) XXX_Size() int {
	return xxx_messageInfo_UploadRequest_ChunkMessage.Size(m)
}
func (m *UploadRequest_ChunkMessage) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadRequest_ChunkMessage.DiscardUnknown(m)
}

var xxx_messageInfo_UploadRequest_ChunkMessage proto.InternalMessageInfo

func (m *UploadRequest_ChunkMessage) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *UploadRequest_ChunkMessage) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

type UploadResponse struct {
	Accepted             bool     `protobuf:"varint,1,opt,name=accepted,proto3" json:"accepted,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *UploadResponse) Reset()         { *m = UploadResponse{} }
func (m *UploadResponse) String() string { return proto.CompactTextString(m) }
func (*UploadResponse) ProtoMessage()    {}
func (*UploadResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_0d572c5447081dfe, []int{3}
}

func (m *UploadResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_UploadResponse.Unmarshal(m, b)
}
func (m *UploadResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_UploadResponse.Marshal(b, m, deterministic)
}
func (m *UploadResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_UploadResponse.Merge(m, src)
}
func (m *UploadResponse) XXX_Size() int {
	return xxx_messageInfo_UploadResponse.Size(m)
}
func (m *UploadResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_UploadResponse.DiscardUnknown(m)
}

var xxx_messageInfo_UploadResponse proto.InternalMessageInfo

func (m *UploadResponse) GetAccepted() bool {
	if m != nil {
		return m.Accepted
	}
	return false
}

func init() {
	proto.RegisterType((*ExistsRequest)(nil), "syncano.codebox.filerepo.v1.ExistsRequest")
	proto.RegisterType((*ExistsResponse)(nil), "syncano.codebox.filerepo.v1.ExistsResponse")
	proto.RegisterType((*UploadRequest)(nil), "syncano.codebox.filerepo.v1.UploadRequest")
	proto.RegisterType((*UploadRequest_MetaMessage)(nil), "syncano.codebox.filerepo.v1.UploadRequest.MetaMessage")
	proto.RegisterType((*UploadRequest_ChunkMessage)(nil), "syncano.codebox.filerepo.v1.UploadRequest.ChunkMessage")
	proto.RegisterType((*UploadResponse)(nil), "syncano.codebox.filerepo.v1.UploadResponse")
}

func init() {
	proto.RegisterFile("syncano/codebox/filerepo/v1/repo.proto", fileDescriptor_0d572c5447081dfe)
}

var fileDescriptor_0d572c5447081dfe = []byte{
	// 373 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x92, 0xcd, 0x6e, 0xda, 0x40,
	0x10, 0xc7, 0x6b, 0x63, 0x28, 0x1d, 0x3e, 0x54, 0xad, 0x7a, 0x40, 0xee, 0xa1, 0xd4, 0x87, 0x0a,
	0xb5, 0xd5, 0x3a, 0x10, 0x89, 0x1c, 0x72, 0x23, 0x8a, 0x14, 0x45, 0xa0, 0x48, 0x8e, 0x72, 0xc9,
	0x6d, 0xb1, 0x27, 0xc6, 0x32, 0x78, 0x1d, 0x76, 0x8d, 0xe0, 0x85, 0xf2, 0x3c, 0x79, 0xa4, 0xc8,
	0xcb, 0x9a, 0x60, 0x25, 0x82, 0xe4, 0xb4, 0xb3, 0xab, 0xff, 0xfe, 0xe6, 0x3f, 0x1f, 0xf0, 0x47,
	0x6c, 0x12, 0x9f, 0x25, 0xdc, 0xf5, 0x79, 0x80, 0x53, 0xbe, 0x76, 0x1f, 0xa2, 0x39, 0x2e, 0x31,
	0xe5, 0xee, 0xaa, 0xef, 0xe6, 0x27, 0x4d, 0x97, 0x5c, 0x72, 0xf2, 0x53, 0xeb, 0xa8, 0xd6, 0xd1,
	0x42, 0x47, 0x57, 0x7d, 0xe7, 0x37, 0xb4, 0x2e, 0xd7, 0x91, 0x90, 0xc2, 0xc3, 0xc7, 0x0c, 0x85,
	0x24, 0xdf, 0xa1, 0x12, 0xe3, 0xa6, 0x63, 0x74, 0x8d, 0xde, 0x37, 0x2f, 0x0f, 0x9d, 0x2e, 0xb4,
	0x0b, 0x89, 0x48, 0x79, 0x22, 0x90, 0xb4, 0xc1, 0xe4, 0xb1, 0x92, 0xd4, 0x3d, 0x93, 0xc7, 0xce,
	0x93, 0x09, 0xad, 0xbb, 0x74, 0xce, 0x59, 0x50, 0x50, 0xc6, 0x60, 0x2d, 0x50, 0x32, 0xa5, 0x69,
	0x0c, 0x86, 0xf4, 0x80, 0x05, 0x5a, 0xfa, 0x49, 0x27, 0x28, 0xd9, 0x04, 0x85, 0x60, 0x21, 0x5e,
	0x7d, 0xf1, 0x14, 0x85, 0xdc, 0x40, 0xd5, 0x9f, 0x65, 0x49, 0xdc, 0x31, 0x15, 0xee, 0xec, 0x13,
	0xb8, 0x8b, 0xfc, 0xdf, 0x2b, 0x6f, 0xcb, 0x21, 0x3f, 0xc0, 0x0a, 0x78, 0x82, 0x9d, 0x4a, 0x5e,
	0x42, 0x9e, 0x26, 0xbf, 0xd9, 0xbf, 0xa0, 0xb1, 0x97, 0xfd, 0x6d, 0x27, 0xec, 0x21, 0x34, 0xf7,
	0x79, 0x84, 0x80, 0x95, 0xb0, 0x05, 0x6a, 0x89, 0x8a, 0xf3, 0xb7, 0x80, 0x49, 0xa6, 0xac, 0x36,
	0x3d, 0x15, 0x8f, 0xbe, 0x42, 0x75, 0xc5, 0xe6, 0x19, 0x3a, 0xff, 0xa1, 0x5d, 0xd8, 0xd3, 0xad,
	0xb4, 0xa1, 0xce, 0x7c, 0x1f, 0x53, 0x89, 0x81, 0x6e, 0xe8, 0xee, 0x3e, 0x78, 0x36, 0xc0, 0xf2,
	0x30, 0xe5, 0x84, 0x41, 0x6d, 0x3b, 0x01, 0xf2, 0xf7, 0x60, 0xe9, 0xa5, 0x49, 0xda, 0xff, 0x3e,
	0xa4, 0xd5, 0x3e, 0x10, 0x6a, 0x5b, 0x67, 0x47, 0x52, 0x94, 0xba, 0x7b, 0x24, 0x45, 0xb9, 0xd4,
	0x9e, 0x71, 0x62, 0x8c, 0xc6, 0xf7, 0xd7, 0x61, 0x24, 0x67, 0xd9, 0x94, 0xfa, 0x7c, 0xe1, 0xde,
	0xea, 0x05, 0xd6, 0x10, 0x96, 0x46, 0xc2, 0x0d, 0x31, 0x71, 0xc3, 0xdd, 0xd3, 0x7b, 0xbb, 0x7d,
	0x5e, 0xc4, 0xd3, 0x9a, 0x5a, 0xf0, 0xd3, 0x97, 0x00, 0x00, 0x00, 0xff, 0xff, 0x0f, 0x2e, 0x87,
	0xe1, 0x0a, 0x03, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RepoClient is the client API for Repo service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RepoClient interface {
	// Exists checks if file was defined in file repo.
	Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error)
	// Upload streams file(s) to server.
	Upload(ctx context.Context, opts ...grpc.CallOption) (Repo_UploadClient, error)
}

type repoClient struct {
	cc *grpc.ClientConn
}

func NewRepoClient(cc *grpc.ClientConn) RepoClient {
	return &repoClient{cc}
}

func (c *repoClient) Exists(ctx context.Context, in *ExistsRequest, opts ...grpc.CallOption) (*ExistsResponse, error) {
	out := new(ExistsResponse)
	err := c.cc.Invoke(ctx, "/syncano.codebox.filerepo.v1.Repo/Exists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *repoClient) Upload(ctx context.Context, opts ...grpc.CallOption) (Repo_UploadClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Repo_serviceDesc.Streams[0], "/syncano.codebox.filerepo.v1.Repo/Upload", opts...)
	if err != nil {
		return nil, err
	}
	x := &repoUploadClient{stream}
	return x, nil
}

type Repo_UploadClient interface {
	Send(*UploadRequest) error
	Recv() (*UploadResponse, error)
	grpc.ClientStream
}

type repoUploadClient struct {
	grpc.ClientStream
}

func (x *repoUploadClient) Send(m *UploadRequest) error {
	return x.ClientStream.SendMsg(m)
}

func (x *repoUploadClient) Recv() (*UploadResponse, error) {
	m := new(UploadResponse)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RepoServer is the server API for Repo service.
type RepoServer interface {
	// Exists checks if file was defined in file repo.
	Exists(context.Context, *ExistsRequest) (*ExistsResponse, error)
	// Upload streams file(s) to server.
	Upload(Repo_UploadServer) error
}

func RegisterRepoServer(s *grpc.Server, srv RepoServer) {
	s.RegisterService(&_Repo_serviceDesc, srv)
}

func _Repo_Exists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ExistsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RepoServer).Exists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/syncano.codebox.filerepo.v1.Repo/Exists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RepoServer).Exists(ctx, req.(*ExistsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Repo_Upload_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RepoServer).Upload(&repoUploadServer{stream})
}

type Repo_UploadServer interface {
	Send(*UploadResponse) error
	Recv() (*UploadRequest, error)
	grpc.ServerStream
}

type repoUploadServer struct {
	grpc.ServerStream
}

func (x *repoUploadServer) Send(m *UploadResponse) error {
	return x.ServerStream.SendMsg(m)
}

func (x *repoUploadServer) Recv() (*UploadRequest, error) {
	m := new(UploadRequest)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Repo_serviceDesc = grpc.ServiceDesc{
	ServiceName: "syncano.codebox.filerepo.v1.Repo",
	HandlerType: (*RepoServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Exists",
			Handler:    _Repo_Exists_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Upload",
			Handler:       _Repo_Upload_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "syncano/codebox/filerepo/v1/repo.proto",
}
